<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Maven 仓库简介]]></title>
    <url>%2F2018%2F10%2F12%2Fmaven-repository%2F</url>
    <content type="text"><![CDATA[何为 Maven 仓库在 Maven 世界中，任何一个依赖、插件或者项目构建的输出，都可称为构件。任何一个构件都有一组坐标来唯一标识。得益于坐标机制，任何 Maven 项目使用任何一个构件的方式都是完全相肉中刺的。据此，Maven 可以在某个地方统一存储管理所有 Maven 项目共享的构件，实际的 Maven 项目将不再各自存储其依赖文件而只需要声明这些依赖的坐标，这个存储的地方就是仓库。Maven 通过仓库来统一管理构件的物理文件。 为了实现重用，项目构建完成后生成的构件也可以安装和部署到仓库，以供其他开发人员和项目使用。 Maven 仓库的分类原格来说，Maven 仓库只有两类：本地仓库和远程仓库。当 Maven 根据坐标寻找构件时，首先会查看本地仓库，找到则直接使用；如果本地仓库不存在此构件，或者需要检查构件是否更新，Maven 就会去远程仓库查找，找到后下载到本地仓库再使用。如果本地仓库和远程仓库都没有需要的构件，则报错。 这里，将远程仓库进一步分为中央仓库、私服和其他公共库，以便说明。 本地仓库一般来说，在 Maven 项目目录下，没有诸如 lib/ 这样目录用来存放依赖文件。当 Maven 在执行编译或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。 本地仓库在本机缓存着从远程仓库下载而来的构件拷贝，以及尚未发布的本地 Maven 项目的临时构建产生的构件输出。一个构件只有在本地仓库中之后，才能由其他 Maven 项目使用。 不管是在 Windows 还是 Linux 上，本地仓库缺省是在用户目录下一个路径名为 .m2/repository/ 的目录。本地仓库的目录位置是可配置的。初始如果不执行任何 Maven 命令，本地仓库目录是不存在的。当用户执行第一条 Maven 命令之后，Maven 才会创建本地仓库。 远程仓库远程仓库可以是一个直正意义的需要通过各种网络协议(如 “file:” 和 “http:”)来进行访问的远程终端库。也可以是公司、团体内部使用的那种架设在局域网或外网的一个文件或 HTTP 服务器上的库，用于在团队和项目间分享私有构件。 中央仓库初始的本地仓库是空的，Maven 必须知道至少一个可用的远程仓库，才能在执行 Maven 命令时下载到需要的构件。中央仓库就是这样一个默认的远程仓库，是一个真正意义的远程仓库。 Maven 的安装文件自带了中央仓库的配置： 123456789101112131415&lt;repositories&gt; &lt;repository&gt; &lt;!-- 中内仓库唯一标识 --&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;!-- 访问地址 --&gt; &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;!-- 表示不从该仓库下载快照版本的构件 --&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 私服私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的 Maven 用户使用。当 Maven 需要下载构件的时候，它从私服请求，如果么服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为 Maven 的下载请求提供服务。此外，一些无法从外部仓库下载到的构件也能从本地上传到私服上供项目共享。 私服的优点： 节省外网带宽； 加速 Maven 构建； 部署第三方构件； 提高稳定性，增强控件； 降低中央仓库的负荷。 流行的 Maven 私服软件，如 Nexus 等。 Maven 仓库的配置本地仓库配置因为硬盘空间等原因，有时会想要自定义本地仓库目录地址。这时，可以编辑文件 ~/.m2/settings.xml，设置 &lt;localRepository> 元素的值为想要的仓库地址。例如： 123&lt;settings&gt; &lt;localRepository&gt;/home/username/MavenLocalRepository/&lt;/localRepository&gt;&lt;/settings&gt; 注意：settings.xml 一般只放在本机。文件格式及内容可参考或从 $M2_HOME/conf/settings.xml 拷贝修改。 远程仓库配置 配置远程仓库 有时，默认的中央仓库无法满足项目的需要，项目依赖的构件存在于另外的远程仓库中，这就需要对远程仓库进行配置。在 &lt;repositories> 元素下，可以使用 &lt;repository> 子元素声明一到多个远程仓库。 例如，配置 JBoss Maven 仓库： 123456789101112131415161718&lt;project&gt; ... &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jboss&lt;/id&gt; &lt;name&gt;JBoss Repository&lt;/name&gt; &lt;url&gt;http://repository.jboss.com/maven2/&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; ...&lt;/project&gt; 注意： 任何一个仓库的声明的 id 必须是唯一的。Maven 自带的中央仓库使用的 id 为 central，如果其他的仓库声明也使用该 id，就会覆盖中央仓库的配置。 配置中的 URL 值指向了仓库的地址，通常都基于 http 协议，可以在浏览器中打开仓库地址浏览构件。 配置中的 &lt;releases> 和 &lt;snapshots> 元素，用来控制 Maven 对于发布版构件和快照构件的下载。&lt;enabled> 子元素：用于打开/关闭 Maven 对于发布版构件和快照构件的下载。&lt;updatePolicy> 子元素：用来配置 Maven 从远程仓库检查更新的频率，缺省值为 daily，表示每天检查一次。可选值还包括：never（从不检查更新）、always（每次构建都检查更新）、interval：x（每隔x分钟检查一次更新，x为整数）。&lt;checksumPolicy> 子元素：用来配置 Maven 检查检验和文件的策略，缺省值为 warn（输出警告）。可选值还包括：fail（校验错误则让构建失败）、ignore（忽略校验错误）。当部署 Maven 构件时，会同时部署对应的检验和文件。在下载构件时，Maven 会验证检验和文件。 12345&lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;ignore&lt;/checksumPolicy&gt;&lt;/snapshots&gt; 配置仓库认证信息 如果管理员为仓库提供了用户名和密码，为了能让 Maven 访问仓库，需要配置认证信息。Maven 使用 settings.xml 文件中的 &lt;servers> 元素及其 &lt;server> 子元素配置仓库谁信息。&lt;server> 元素的 id 必须与 POM 中需要认证的 repository 元素的 id 完全一致。 1234567891011&lt;settings&gt; ... &lt;servers&gt; &lt;server&gt; &lt;id&gt;myproj&lt;/id&gt; &lt;username&gt;repo-user&lt;/username&gt; &lt;password&gt;repo-pwd&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; ...&lt;/settings&gt; 部署配置私服的一大作用是部署第三方构件，包括组织内部生成的构件以及一些无法从外部仓库直接获取的构件。Maven 可以通过配置 &lt;distributionManagement> 元素来将项目生成的构建部署到仓库中。 配置部署项目构件到远程库： 123456789101112131415161718192021&lt;proejct&gt; ... &lt;distributionManagement&gt; &lt;repository&gt; &lt;uniqueVersion&gt;false&lt;/uniqueVersion&gt; &lt;id&gt;corp1&lt;/id&gt; &lt;name&gt;Corporate Repository&lt;/name&gt; &lt;url&gt;scp://repo/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion&gt;true&lt;/uniqueVersion&gt; &lt;id&gt;propSnap&lt;/id&gt; &lt;name&gt;Propellors Snapshots&lt;/name&gt; &lt;url&gt;sftp://propellers.net/maven&lt;/url&gt; &lt;layout&gt;legacy&lt;/layout&gt; &lt;/snapshotRepository&gt; ... &lt;/distributionManagement&gt; ...&lt;/project&gt; 部署 Maven 项目的网站和文档： 123456789101112&lt;proejct&gt; ... &lt;distributionManagement&gt; &lt;site&gt; &lt;id&gt;com.company.proj&lt;/id&gt; &lt;name&gt;Company Project Website&lt;/name&gt; &lt;url&gt;scp://www.company.com/home/projects/proj/public_html/&lt;/url&gt; &lt;/site&gt; ... &lt;/distributionManagement&gt; ...&lt;/project&gt; 配置将当前 Maven 项目以新的构件的形式发布到另一个库： 1234567891011121314&lt;proejct&gt; ... &lt;distributionManagement&gt; ... &lt;relocation&gt; &lt;groupId&gt;org.apache&lt;/groupId&gt; &lt;artifactId&gt;my-project&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;message&gt;We have moved the Project under Apache&lt;/message&gt; &lt;/relocation&gt; ... &lt;/distributionManagement&gt; ...&lt;/project&gt; 镜像如果仓库 X 可以提供仓库 Y 存储的所有内容，那么就可以认为 X 是 Y 的一个镜像。考虑到地理位置的因素，可以考虑为远程仓库配置一个本地镜像，以提供更快的服务。 如编辑 settings.xml 来配置 Maven 镜像以替代中央仓库。 12345678910111213&lt;settings&gt; ... &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;internal-repository&lt;/id&gt; &lt;name&gt;Internal Repository Mirror&lt;/name&gt; &lt;url&gt;http://192.168.1.100/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; ...&lt;/settings&gt; mirror 中 id、name、url 子元素与一般仓库配置无异，表示该镜像仓库的唯一标识符、名称以及地址。&lt;mirrorOf> 的值为 central，表示该配置为中央仓库的镜像，任何对于中央仓库的请求都会转到该镜像。 &lt;mirrorOf> 配置规则： &lt;mirrorOf>*&lt;/mirrorOf>：匹配所有远程仓库。 &lt;mirrorOf>external:*&lt;/mirrorOf>：匹配所有远程仓库，使用 localhost 的除外。 &lt;mirrorOf>repo1,repo2&lt;/mirrorOf>：匹配仓库 repo1 和 repo2，使用逗号分隔多个远程仓库。 &lt;mirrorOf>*,!repo1&lt;/mirrorOf>：匹配所有非repo1远程仓库。 参考资源 Maven 学习笔记合集 Maven 实战 Introduction to Repositories]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Dev</tag>
        <tag>ReadingNotes</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 依赖配置]]></title>
    <url>%2F2018%2F10%2F10%2Fmaven-dependencies-configuration%2F</url>
    <content type="text"><![CDATA[Maven 依赖配置的基本结构123456789101112131415161718192021&lt;project&gt; ...... &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;...&lt;/groupId&gt; &lt;artifactId&gt;...&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt; &lt;type&gt;...&lt;/type&gt; &lt;scope&gt;...&lt;/scope&gt; &lt;optional&gt;..&lt;/optional&gt; &lt;exclusions&gt; &lt;exclusion&gt; ... &lt;/exclusion&gt; ... &lt;/exclusions&gt; &lt;/dependency&gt; ... &lt;/dependencies&gt; ......&lt;/project&gt; 通常，一个项目都会用到一个或者多个项目依赖。因此，在 pom.xml 的根元素 project 下的 dependencies 可以包含一到多个 dependency 元素，以声明一或者多个项目依赖。 一个 dependency 元素可以包含 groupId、artifactId、version、type、classifier、scope、systemPath、optional、exclusions 等元素。其中 groupId、artifactId、version 对每一个 dependency 元素配置是必须的。optional 用于标记依赖是否可选。另外，systemPath 仅当 scope 为 system 使用，官网上明确不赞成使用。 依赖项目坐标：groupId、artifactId 和 versiongroupId、artifactId、version 对每一个 dependency 元素来说是必须的。它们是依赖的Maven坐标，对于任何一个 Maven 项目而言，基本坐标是最重要的，Maven 会根据坐标从资源库中找到需要的依赖。 version 配置version 元素定义了依赖项目的版本需求，用于计算有效的依赖版本号。version 允许使用如下语法格式： 1.0: 对1.0版本的非硬性需求（建议版本） [1.0]: 硬性需求1.0版本 (,1.0]: x &lt;= 1.0 [1.2,1.3]: 1.2 &lt;= x &lt;= 1.3 [1.0,2.0): 1.0 &lt;= x &lt; 2.0 [1.5,): x &gt;= 1.5 (,1.0],[1.2,): x &lt;= 1.0 or x &gt;= 1.2；多个设置用逗号分隔 (,1.1),(1.1,): 排除1.1版本 例如：配置 junit 依赖如下，Maven 将计算使用 junit-4.3.jar 作为 test scope 依赖包。 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;[4.1,4.3]&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 版本规则接受使用“.”或“-”来组合“版本数字(number tokens 数字标记)”和“版本限定词(non-number tokens 非数字标记)”形成的字符串系列。该系列在被计算时将会从后开始将(0, “”, “final”, “ga”)去掉，如此： “1.0.0” -&gt; 1 “1.ga” -&gt; 1 “1.final” -&gt; 1 “1.0” -&gt; 1 “1.” -&gt; 1 “1-“ -&gt; 1 “1.0.0-foo.0.0” -&gt; 1-foo “1.0.0-0.0.0” -&gt; 1 版本序列比较规则： 数字标记部分采用自然序（natural order）。 非数字标记（版本限定词）部分采用字典序（alphabetical order），除了业界习惯性版本规则： “alpha” &lt; “beta” &lt; “milestone” &lt; “rc” = “cr” &lt; “snapshot” &lt; “” = “final” = “ga” &lt; “sp” “.qualifier” &lt; “-qualifier” &lt; “-number” &lt; “.number” 例如： “1” &lt; “1.1” “1-snapshot” &lt; “1” &lt; “1-sp” “1-foo2” &lt; “1-foo10” “1.foo” &lt; “1-foo” &lt; “1-1” &lt; “1.1” “1.ga” = “1-ga” = “1-0” = “1.0” = “1” “1-sp” &gt; “1-ga” “1-sp.1” &gt; “1-ga.1” “1-sp-1” &lt; “1-ga-1” = “1-1” “1-a1” = “1-alpha-1” classifier 附属构件配置classifier 通常用于区分从同一POM构建的具有不同内容的构件（artifact）。它是可选的，它可以是任意的字符串，附加在版本号之后。需要紧跟 version 元素进行书写。其主要有两个用途： 指定依赖项目组成部分，如源代码、javadoc、类文件等 如需要 junit 的 javadoc 包 junit-4.3-javadoc.jar，则配置 dependency 如下： 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.3&lt;/version&gt; &lt;classifier&gt;javadoc&lt;/classifier&gt;&lt;/dependency&gt; 若需要源码包 junit-4.3-sources.jar，则可配置 如下： 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.3&lt;/version&gt; &lt;classifier&gt;sources&lt;/classifier&gt;&lt;/dependency&gt; 指定依赖项目的JDK版本 如项目依赖 json-lib-2.2.2-jdk13.jar，则配置 dependency 如下： 123456&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;classifier&gt;jdk13&lt;/classifier&gt;&lt;/dependency&gt; 若项目依赖 json-lib-2.2.2-jdk15.jar，则可配置如下： 123456&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;/dependency&gt; 依赖类型：typetype 元素用于声明依赖的类型，对应于项目坐标定义的 packaging（打包方式）。大多数情况下，该元素不必特别声明，其缺省值为 jar。 依赖范围：scopeMaven 在编译项目主代码（即编译 compile 范围）时需要使用一套 classpath，在编译运行测试用例（即测试 test 范围）时会需要使用另外一套 classpath。最后，实际发布运行时可能又会使用一套 classpath。比如一个 J2EE 项目，在编译主代码时通常需要依赖 servlet-api 包，在编译运行测试代码时需要依赖 junit 包，而在部署到服务器时则无需这两个包。 依赖范围就是用来控制依赖与这三种 classpath（编译 classpath、测试 classpath、运行 classpath）的关系，Maven 有以下几种依赖范围： compile：编译依赖范围。如果没有指定 scope，就会默认使用该依赖范围。compile 依赖范围，对于编译、测试、运行三种 classpath 都有效。 test：测试依赖范围，仅对于测试 classmate 有效。典型的例子是 JUnit，只有在编译和运行测试的时候才需要。 provided：已提供依赖范围。该依赖范围，对于编译和测试 classpath 都有效，但对运行 classpath 无效。典型的例子是 servlet-api，编译和测试 J2EE 项目时都需要该依赖，但在部署运行项目时，由于容器已经提供，故不需要重复引入。 runtime：运行时依赖范围。该依赖范围，对于测试和运行 classpath 有效，但在编译主代码时无效。典型的例子是 JDBC 驱动实现，项目主代码的编译只需要 JDK 提供的 JDBC 接口，只有在测试和项目运行时才真正需要。 system：系统依赖范围。系统依赖范围和三种 classpath 的关系，和 provided 依赖范围完全一致。但是由于此类依赖不是通过 Maven 仓库解析，而是往往与本机系统绑定，在使用时必须通过 systemPath 元素显示地指定依赖文件的路径。可能造成构建的不可移植，因此应该谨慎使用。 import：导入依赖范围。该依赖范围为 Maven 2.0.9 之后新增，它只使用在 中，表示从其它的 pom 中导入 dependency 的配置。 systemPath 元素可以引用环境变量，如： 1234567&lt;dependency&gt; &lt;groupId&gt;javax.sql&lt;/groupId&gt; &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;java.home&#125;/lib/rt.jar&lt;/systemPath&gt;&lt;/dependency&gt; 依赖范围与 classpath 的关系 依赖范围 对编译classpath有效 对测试classpath有效 对运行时classpath有效 典型例子 compile Y Y Y json test - Y - junit provided Y Y - servlet-api runtime - Y Y JDBC 驱动实现 system Y Y - 本地的，Maven仓库之外的类库文件 传递性依赖机制何为传递性依赖传递性依赖，举例来说就是“项目A”有一个 compile 范围的“项目B”依赖，同时“项目B”又有一个 compile 范围的“项目C”依赖，那么“项目C”就会成为“项目A”的 compile 范围依赖，“项目C”就是“项目A”的一个传递性依赖。 有了传递性依赖机制，Maven 会解析各个直接依赖的 POM，将那些必要的间接依赖以传递依赖的形式引入到项目中。一方面大大简化和方便了依赖声明，另一方面，大部分情况下我们只需要关心项目的直接依赖是什么，而不用考虑这些直接依赖会引入什么传递性依赖。 注意：可选依赖，即 optional 为 true 的依赖，依赖将不会得以传递。原则上，是不应该使用可选依赖的。因为使用可选依赖的原因通常是某一项目实现了多个特性，且这些特性分别被多个项目所依赖，这违背了面向对象设计的“单一职责性原则”。 传递性依赖范围依赖范围不仅可以控制依赖与三种 classmate 的关系，还对传递性依赖产生影响。假设 A 依赖于 B，B 依赖于 C，我们说 A 对于 B 是第一直接依赖，B 对于 C 是第二直接依赖，A 对于 C 是传递性依赖。那么第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围。 传递性依赖范围规则 第一直接依赖范围 \ 第二直接依赖范围 compile test provided runtime compile compile - - runtime test test - - test provided provided - provided provided runtime runtime - - runtime 规律： 当第二直接依赖的范围是 compile 时，传递性依赖的范围与第一直接依赖的范围一致； 当第二直接依赖的范围是 test 时，依赖不会得传递； 当第二直接依赖的范围是 provided 时，只传递第一直接依赖范围也是 provided 的依赖，且传递性依赖的范围同样也为 provided； 当第二直接依赖的范围是 runtime 的时候，除 compile 对应性依赖范围为 runtime 外，其余皆与第一直接依赖的范围一致。 依赖调解原则Maven 为依赖冲突定义了两条调解原则： 第一原则：同一依赖构件，不同版本，路径最近者优先。 例如，项目 A 对 X 有这样的两条依赖路径：A -&gt; B -&gt; C -&gt; X(1.0)A -&gt; C -&gt; X(2.0) 依据第一原则，X(2.0)将会被解析使用。 第二原则：同一依赖构件，不同版本，若路径相同，则第一声明者优先。 同一依赖构件，不同版本，路径也相同的情况在 Maven 2.0.8 及之前的版本中是不确定的，但从 Maven 2.0.9 开始，为了尽可能避免构建的不确定性，Maven 定义了依赖调解的第二原则。 例如，同样有两条依赖路径：A -&gt; B -&gt; Y(1.0)A -&gt; C -&gt; Y(2.0) 依据第二原则，Y(1.0)将会被解析使用。 最佳实践依赖排除：exclusions传递性依赖会给项目隐式地引入很多依赖，这极大地简化了项目依赖的管理，但有些时候这种特性也会带来问题。比如，传递性依赖的项目版本过旧或不稳定，或者涉及版权问题。那么就需要排除传递性依赖，而用替代的直接依赖。这是就需要用到 exclusions 元素。 exclusions 元素可以包含一个或者多个 exclusion 子元素，可以排除一个或者多个传递性依赖。需要注意的是，声明 exclusion 的时候只需要 groupId 和 artifactId，而不需要 version 元素。 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;com.xxx.xxx&lt;/groupId&gt; &lt;artifactId&gt;dp01&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.xxx.xxx&lt;/groupId&gt; &lt;artifactId&gt;dp02&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.xxx.xxx&lt;/groupId&gt; &lt;artifactId&gt;dp02-replace&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 依赖归类对于来自同一项目的不同模块，如 org.springframework:spring-core:2.5.6、org.springframework:spring-beans:2.5.6、org.springframework:spring-context:2.5.6 和org.springframework:spring-context-support:2.5.6，如果需要对这些模块同时进行依赖，通常所有这些依赖的版本都是相同的。而且可以预见，如果将来需要升级，这些依赖的版本会一起升级。这时，就需要考虑进行依赖归类，在 POM 中使用 properties 元素引入版本变量。 12345678910111213141516171819202122232425262728293031&lt;project&gt; ...... &lt;properties&gt; &lt;spring.version&gt;2.5.6&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ......&lt;/project&gt; 依赖优化Maven 提供了一些命令以帮助我们优级化依赖配置。 查看项目依赖 1mvn dependency:list 查看项目依赖树 1mvn dependency:tree 分析项目依赖 1mvn dependency:analyze 注意：dependency:analyze 只会分析编译主代码和测试代码需要用到的依赖，一些执行测试和运行时需要的依赖它无能为力。 参考资源 Maven 学习笔记合集 POM Dependencies Dependency 元素 Maven 实战]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Dev</tag>
        <tag>ReadingNotes</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何降级/切换 Ubuntu 系统 Linux 内核启动版本]]></title>
    <url>%2F2018%2F10%2F09%2Fswitch-ubuntu-linux-kernel%2F</url>
    <content type="text"><![CDATA[1.查看系统可用的 Linux 内核查看启动菜单 “Advanced options for Ubuntu” 的子选项，以确定可选的 Linux 内核信息： 1grep menuentry /boot/grub/grub.cfg 可以看到子选项： ‘Ubuntu, with Linux 4.4.0-104-generic’ 2.修改Grub，设置内核启动版本用 Gedit 编辑器打开 grub 文件： 1sudo gedit /etc/default/grub 将 GRUB_DEFAULT=0 // 0表示系统当前启动的内核序号 修改为想要启动的内核版本对应子选项： GRUB_DEFAULT=“Advanced options for Ubuntu &gt; Ubuntu, with Linux 4.4.0-104-generic” 3.更新Grub1sudo update grub 或使用更标准的做法： 1sudo grub-mkconfig -o /boot/grub/grub.cfg 此时如果有错误，则检查 GRUB_DEFAULT 是否所选 Linux 内核版本不在次级选项中，若是则需要将前面部分”Advanced options for Ubuntu&gt;”去掉后重新执行。 无错误提示，即可reboot重启系统。 4.查看当前运行内核查看系统当前运行内核信息，以确认降级是否成功。 1uname -r(或-a) 5.安装Linux内核查看可安装的内核： 1sudo apt-cache search linux-image | grep generic 安装新内核： 1sudo apt-get install linux-image-4.4.0-108-generic 4.卸载Linux内核1sudo apt-get remove(或用purge) linux-image-4.4.0-105-generic]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Linux Kernel</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu小技巧：查看软件包版本及安装位置]]></title>
    <url>%2F2018%2F09%2F29%2Fview-ubuntu-software-info%2F</url>
    <content type="text"><![CDATA[本文以chromium浏览器软件来进行示例和讲解 查看软件版本信息 aptitude show xxx 安装aptitude: sudo apt-get install aptitude 运行查看chromium-browser软件信息： aptitude show chromium-browser 123456789101112131415161718192021~$ aptitude show chromium-browserPackage: chromium-browserVersion: 69.0.3497.81-0ubuntu0.18.04.1State: installedAutomatically installed: noPriority: optionalSection: universe/webMaintainer: Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;Architecture: amd64Uncompressed Size: 213 MDepends: .......PreDepends: dpkg (&gt;= 1.15.6)Recommends: chromium-browser-l10nSuggests: webaccounts-chromium-extension, unity-chromium-extension, adobe-flashpluginConflicts: chromium-browser-inspector, chromium-browser-inspector:i386, chromium-browser:i386Replaces: chromium-browser-inspector, chromium-browser-inspector:i386Provides: chromium-browser-inspector, www-browserDescription: Chromium web browser, open-source version of Chrome An open-source browser project that aims to build a safer, faster, and more stable way for all Internet users to experience the web.Homepage: https://chromium.googlesource.com/chromium/src/ 可见，aptitude show命令将输出所查软件的包名、版本、维护人、依赖包列表、描述、主页等等信息。结果信息相当丰富。 apt-show-versions xxx 安装 apt-show-versions: sudo apt-get install apt-show-versions 运行查看chromium-browser软件信息： apt-show-versions chromium-browser 1234~$ apt-show-versions chromium-browserchromium-browser:amd64/bionic-security 69.0.3497.81-0ubuntu0.18.04.1 uptodatechromium-browser:i386 not installed 可见，apt-show-versions命令仅只打印所查软件的版本信息。 查看软件包是否安装 - dpkg dpkg -l | grep xxx 1234~$ dpkg -l | grep chromium-browserii chromium-browser 69.0.3497.81-0ubuntu0.18.04.1 amd64 Chromium web browser, open-source version of Chromeii chromium-browser-l10n 69.0.3497.81-0ubuntu0.18.04.1 all chromium-browser language packages 查看软件包安装位置 - dpkg dpkg -L xxx 123456789101112131415161718192021~$ dpkg -L chromium-browser/./etc/etc/chromium-browser/etc/chromium-browser/customizations/etc/chromium-browser/customizations/00-example/etc/chromium-browser/default/etc/chromium-browser/policies/etc/chromium-browser/policies/managed/etc/chromium-browser/policies/recommended/etc/default/etc/default/chromium-browser/usr/usr/bin/usr/bin/chromium-browser/usr/lib/usr/lib/chromium-browser/usr/lib/chromium-browser/MEIPreload/usr/lib/chromium-browser/MEIPreload/manifest.json......]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Tutorial</tag>
        <tag>Command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Maven]]></title>
    <url>%2F2018%2F09%2F27%2Fuse-maven%2F</url>
    <content type="text"><![CDATA[Maven简介什么是MavenMaven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。 Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 在多个开发团队环境时，Maven可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。 Maven提供了开发人员的方式来管理： Builds Documentation Reporting Dependencies SCMs Releases Distribution mailing list 概括地说，Maven简化和标准化项目建设过程。处理编译，分配，文档，团队协作和其他任务的无缝连接。 Maven增加可重用性并负责建立相关的任务。 Maven目标Maven主要目标是提供给开发人员： 项目是可重复使用，易维护，更容易理解的一个综合模型。 插件或交互的工具，这种声明性的模式。 Maven项目的结构和内容在一个XML文件中声明，pom.xml 项目对象模型（POM），这是整个Maven系统的基本单元。 Maven常用概念 Maven本地资源库 Maven 的本地资源库是用来存储项目的依赖库，默认的文件夹是 “.m2” 目录，可能需要将其更改为另一个文件夹。 Maven中央存储库 Maven 中央存储库是 Maven 用来下载所有项目的依赖库的默认位置。 Maven坐标（Coordinate） Maven坐标定义了一组标识，它们可以用来唯一标识一个项目，一个依赖，或者Maven POM里的一个插件，看一下下面的这个POM文件。 123456789101112131415161718192021&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.4.0&lt;/modelVersion&gt; &lt;groupId&gt;mavenbook&lt;/groupId&gt; &lt;artifactId&gt;mybook&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;Maven Quick Start Archetype&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/denpendency&gt; &lt;/denpendencies&gt;&lt;/project&gt; 这个项目的坐标：groupId、artifactId、version 和 packaging。这些组合的标识符拼成了一个项目的坐标，就像任何其它的坐标系统，一个Maven坐标是一个地址，即“空间”里的某个点：从一般到特殊。当一个项目通过依赖，插件或者父项目引用和另外一个项目关联的时候，Maven通过坐标来精确定位一个项目。Maven坐标通常用冒号来作为分隔符来书写，像这样的格式: groupId:artifactId:packaging:version。在上面的pom.xml中，它的坐标可以表示为 mavenbook:my-app:jar:1.0-SNAPSHOT.这个符号也适用于项目依赖，我们的项目依赖JUnit的3.8.1版本，它包含了一个对 junit:junit:jar:3.8.1 的依赖。 groupId: 团体、公司、小组、组织、项目或者其它团体。团体标识的约定是：以创建这个项目的组织名称的逆向域名(reverse domain name)开头。来自 Sonatype 的项目有一个以 com.sonatype 开头的 groupId，而 Apache Software 的项目有以 org.apache 开头的groupId。 artifactId: 在groupId下的表示一个单独项目的唯一标识符。 version: 一个项目的特定版本。发布的项目有一个固定的版本标识来指向该项目的某一个特定的版本。而正在开发中的项目可以用一个特殊的标识，这种标识给版本加上一个“SNAPSHOT”的标记。 项目的打包格式也是Maven坐标的重要组成部分，但是它不是项目唯一标识符的一个部分。一个项目的 groupId:artifactId:version 使之成为一个独一无二的项目；你不能同时有一个拥有同样的 groupId、artifactId 和 version 标识的项目。 packaging: 项目的类型，默认是jar，描述了项目打包后的输出。类型为jar的项目产生一个JAR文件，类型为war的项目产生一个web应用。 在其它“Maven化”项目构成的巨大空间中，这四个元素是定位和使用某个特定项目的关键因素。Maven仓库(repositories)（公共的，私有的，和本地的）是通过这些标识符来组织的。当一个项目被安装到本地的Maven仓库，它立刻能被任何其它的项目所使用。而我们所需要做的只是，在其它项目用使用Maven的唯一坐标来加入对这个特定构件的依赖。 安装配置Maven无论是Windows还是Ubuntu，安装配置Maven的基本步骤大致相似，一般都按照下载、解压、配置环境变量、验证等几步走。 本文以Ubuntu变例来进行记录。 下载Maven从Apache Maven下载apache-maven-3.5.4-bin.tar.gz: 1wget http://mirrors.shu.edu.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz 解压下载包到安装目录解压apache-maven-3.5.4-bin.tar.gz到HOME目录： 1tar zxvf apache-maven-3.5.4-bin.tar.gz -C ~ 配置Maven环境变量在 /etc/profile 或 ~/.profile 中添加Maven环境变量： 123export M2_HOME=/home/username/apache-maven-3.3.91PATH=$M2_HOME/bin:$PATH 注： Ubuntu中可以直接用命令来完成Maven安装。$ sudo apt-get install maven Windows系统的环境变量配置和JDK类似： 验证安装是否成功12345678$ mvn -v1Apache Maven 3.5.2Maven home: /usr/share/mavenJava version: 1.8.0_144, vendor: Oracle CorporationJava home: /home/username/Java/jdk1.8/jreDefault locale: en_US, platform encoding: UTF-8OS name: "linux", version: "4.15.0-36-generic", arch: "amd64", family: "unix" 配置本地仓库不修改配置的话，下载的文件都会保存到本地仓库 ~/.m2/repository 中。若需指定本地仓库，可修改 $M2_HOME/conf/settings.xml 或将其 copy 到 ~/.m2/settings.xml 再修改 为指定目录。 1&lt;localRepository&gt;/home/username/.m2/localRepository&lt;/localRepository&gt; 配置m2eclipse在较新的Eclipse中已经集成了m2eclipse，打开 Windows-&gt;Preferences，可以看到Maven相关的配置项。 You can install the lastest M2Eclipse release (1.8.3) by using the following update site from within Eclipse: http://download.eclipse.org/technology/m2e/releases There are also development builds available. Information on how to install those can be found here. 值得注意的是Embedded内置的默认maven版本是我们即将要修改的，可以通过Add按钮来选择新安装的Maven进行添加。 新建Demo项目使用mvn命令新建Maven项目使用 mvn 命令生成Maven项目，需要按照提示选择项目的Archetype并设置正确的Maven坐标(Group Id, Artifact Id, Version)及类包名(Package)。 1234567891011121314151617181920212223242526272829303132333435$ mvn archetype:generate[INFO] Scanning for projects.........Choose archetype:......Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 7:......Define value for property 'groupId': com.eric.mvndemoDefine value for property 'artifactId': hellomavenDefine value for property 'version' 1.0-SNAPSHOT: :Define value for property 'package' com.eric.mvndemo: : hellomavenConfirm properties configuration:groupId: com.eric.mvndemoartifactId: hellomavenversion: 1.0-SNAPSHOTpackage: hellomaven Y: :[INFO] ----------------------------------------------------------------------------[INFO] Using following parameters for creating project from Old (1.x) Archetype: maven-archetype-quickstart:1.1[INFO] ----------------------------------------------------------------------------[INFO] Parameter: basedir, Value: /home/username/Workspace[INFO] Parameter: package, Value: hellomaven[INFO] Parameter: groupId, Value: com.eric.mvndemo[INFO] Parameter: artifactId, Value: hellomaven[INFO] Parameter: packageName, Value: hellomaven[INFO] Parameter: version, Value: 1.0-SNAPSHOT[INFO] project created from Old (1.x) Archetype in dir: /home/username/Workspace/hellomaven[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 02:16 min[INFO] Finished at: 2018-09-27T16:37:15+08:00[INFO] Final Memory: 17M/260M[INFO] ------------------------------------------------------------------------ 使用Eclipse向导新建Maven项目 选择“Maven Project” 选择项目名和位置 选择 Archetype 这里我们创建的是一个简单的Java Demo项目，使用缺省选项即可。 输入 Archetype 参数 即设置项目的Maven坐标(Group Id, Artifact Id, Version)及类包名(Package)等。 项目结构 参考：标准Maven项目结构 编写项目代码 编写主代码 1234567891011package com.eric.mvndemo;public class HelloMaven &#123; public String sayHello() &#123; return "Hello, maven!"; &#125; public static void main(String[] args) &#123; System.out.println((new HelloMaven()).sayHello()); &#125;&#125; 编写junit测试代码 123456789101112package com.eric.mvndemo;import static org.junit.Assert.*;import org.junit.Test;public class HelloMavenTest &#123; @Test public void testSayHello() &#123; String rst = (new HelloMaven()).sayHello(); assertEquals("Hello, maven!", rst); &#125;&#125; 编写 pom.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.eric&lt;/groupId&gt; &lt;artifactId&gt;mvndemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;Maven Demo&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; pom.xml 修改保存后，需要在项目节点 mvndemo 上右击弹出菜单选择执行 Maven-&gt;Update Project…以更新项目的Maven Dependencies相关依赖jar包。 编译构建 Maven 项目Maven 阶段（Maven Phases）及命令目标一个 Maven 生命周期阶段是在被 Maven 称为“构建生命周期”中的一个步骤。生命周期是包含在一个项目构建中的一系列有序的阶段。Maven 可以支持许多不同的生命周期，但是最常用的生命周期是默认的 Maven 生命周期，这个生命周期中一开始的一个阶段是验证项目的基本完整性，最后的一个阶段是把一个项目发布成产品。 validate: 验证项目正确而且所有必要信息可用 compile: 编译项目源代码 test: 编译执行测试用例 package: 编译代码并按分发格式打包，比如 jar integration-test: 集成测试 verify: 检查包的有效性及质量标准 install: 安装包到本地仓库，以作为其他项目的依赖 deploy: 部署发布最终包到远程仓库，以供其他开发者和项目共享 除此之外，还有两个很常用的生命周期阶段。 clean: 构建前清理旧的构件 site: 生成项目的站点文档 Maven 生命周期阶段（phase）实际上对应映射了 Maven 的插件目标。因此，Maven 命令行并没有指定一个插件目标，而是指定了一个 Maven 生命周期阶段。 mvn &lt;phase> args 例如： 1mvn clean dependency:copy-dependencies package 这个命令将清理项目、拷贝依赖和打包项目。 注意：可在一条命令中同时指定多个目标。 用 mvn 命令构建在 pom.xml 所在目录下执行 mvn 命令。 如下命令将完成对项目的清理、测试和打包： 1234567891011121314151617181920212223242526~/Workspace/mvndemo$ mvn clean test package[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building Maven Demo 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------......------------------------------------------------------- T E S T S-------------------------------------------------------Running com.eric.mvndemo.HelloMavenTestTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.019 secResults :Tests run: 1, Failures: 0, Errors: 0, Skipped: 0......[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 4.151 s[INFO] Finished at: 2018-09-27T15:43:46+08:00[INFO] Final Memory: 21M/193M[INFO] ------------------------------------------------------------------------ 执行成功后，一个新的项目打包文件 mvndemo-0.0.1-SNAPSHOT.jar 将生成在target目录中。 通过 Eclipse 构建也可以通过 Eclipse 的 “Run As -&gt; Maven build” 来运行 Maven 命令，初次运行需要进行配置。 Maven build 配置主要是需要对插件目标（Goals）进行设置： 无响应问题处理在 Eclipse 执行 Maven 会发现没任何响应，控制台也没任何信息输出。这时，需要对 JRE 进行配置，增加一个VM参数： -Dmaven.multiModuleProjectDirectory=$M2_HOME 最好直接对已安装的 JRE 进行相应设置，这样可以保证 “Run As” 下的所有子菜单都能正确工作。 构建可运行的 jar一个可运行的jar中，需要在其 META-INF/MANIFEST.MF 中指定正确的 Main-Class。 为了构建这样的jar，我们需要对 pom.xml 进行配置以指导生成正确的 MANIFEST.MF。这需要借助 Maven 的 shade 插件 maven-shade-plugin。 1234567891011121314151617181920212223242526272829303132333435&lt;project&gt; ...... &lt;build&gt; ...... &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt; &lt;manifestEntries&gt; &lt;Main-Class&gt;com.eric.mvndemo.HelloMaven&lt;/Main-Class&gt; &lt;X-Compile-Source-JDK&gt;1.8&lt;/X-Compile-Source-JDK&gt; &lt;X-Compile-Target-JDK&gt;1.8&lt;/X-Compile-Target-JDK&gt; &lt;/manifestEntries&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 如此，通过 mvn package 生成的 jar 将是一个可运行的jar. 123~/Workspace/mvndemo$ java -jar ./target/mvndemo-0.0.1-SNAPSHOT.jarHello, maven! 参考： Setting Manifest Entries with the ManifestResourceTransformer 安装构件（jar）到本地仓库Maven 已经提供了一个目标在 maven-install-plugin 中，用于帮助安装一个 JAR 到本地仓库。命令格式为： mvn install:install-file -Dfile=&lt;path-to-file> -DgroupId=&lt;group-id> -DartifactId=&lt;artifact-id> -Dversion=&lt;version> -Dpackaging=&lt;packaging> 如果已经定义了一个 pom.xm，命令格式写为： mvn install:install-file -Dfile=&lt;path-to-file> -DpomFile=&lt;path-to-pomfile> v2.5 之后，maven-install-plugin 已经得到极大优化。如果 JAR 是由 Apache Maven 构建的，它将在其 META-INF 目录中包含一个 pom.xml 文件。这时，命令可以进一步简化为： mvn install:install-file -Dfile=&lt;path-to-file> 例如： 123456789101112131415161718~/Workspace/mvndemo$ mvn install:install-file -Dfile=./target/mvndemo-0.0.1-SNAPSHOT.jar -DgroupId=com.eric -DartifactId=mvndemo -Dversion=0.0.1-SNAPSHOT -Dpackaging=jar[INFO] Scanning for projects...[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building Maven Demo 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ mvndemo ---[INFO] Installing /home/username/Workspace/mvndemo/target/mvndemo-0.0.1-SNAPSHOT.jar to /home/username/.m2/repository/com/eric/mvndemo/0.0.1-SNAPSHOT/mvndemo-0.0.1-SNAPSHOT.jar[INFO] Installing /tmp/mvninstall3743027047168711880.pom to /home/username/.m2/repository/com/eric/mvndemo/0.0.1-SNAPSHOT/mvndemo-0.0.1-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 0.847 s[INFO] Finished at: 2018-10-12T15:50:42+08:00[INFO] Final Memory: 8M/212M[INFO] ------------------------------------------------------------------------ 执行成功后，可在本地仓库中找到该项目包： 参考资源 Maven 学习笔记合集]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Maven</category>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>Dev</tag>
        <tag>ReadingNotes</tag>
        <tag>Maven</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 学习笔记合集]]></title>
    <url>%2F2018%2F09%2F27%2Fmaven-collection%2F</url>
    <content type="text"><![CDATA[初识Maven Maven 依赖配置 Maven 仓库简介]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Dev</tag>
        <tag>ReadingNotes</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github 分支操作]]></title>
    <url>%2F2017%2F12%2F01%2Fgithub-branch-operation%2F</url>
    <content type="text"><![CDATA[初始化提交 建立 git 仓库 1git init 将项目的所有文件添加到仓库中 1git add . 将 add 的文件 commit 到仓库 1git commit -am "xxx" 登录 github，创建自己的 Repository 将本地的仓库关联到 github 上 1git remote add origin git@github.com:zhengdao/repository.git 注： 当使用 SSH 方式时，应当使用 Github 的 git 协议，否则每次 push 都会提示输入Github 的用户名和密码。 pull 一下 1git pull origin master 上传代码到 github 远程仓库 1git push -u origin master 查看分支1git branch 创建分支1git branch branchname 切换分支1git checkout branchname 提交分支1git push -u origin branchname 分支合并1git merge branchname 删除分支1git branch -D branchname 1git push origin :branchname 注：删除分支之前，需要对 Github 分支进行设置，将默认分支设成另外的非删除分支。例如：当前有两个分支 master 和 gh-pages，现想删除 master 分支。那么需先将默认分支切换成 gh-pages 然后再用命令进行删除。 切换远端库地址 查看当前远端库绑定 1git git remote -v 显示： 123$ git remote -vorigin https://github.com/zhengdao/repository.git (fetch)origin https://github.com/zhengdao/repository.git (push) 删除当前远端库绑定 1git remote rm origin 重新绑定远端库地址 1git remote add origin git@github.com:zhengdao/repository.git]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Dev</tag>
        <tag>ReadingNotes</tag>
        <tag>Version Control</tag>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坑爹的RegExp test()]]></title>
    <url>%2F2017%2F02%2F27%2Fstrang-rexExp-test%2F</url>
    <content type="text"><![CDATA[最近在公司用Javascript实现前端QuickSearch功能，偶尔触及RegExp对象的test()方法。大致有类似的代码： 1234567891011var texts = ["item1", "item2", "item3", "item4", "item5", "item6"];var pattern = new RegExp("it", "ig");function check() &#123; var len = texts.length, text, isMatched = false; for(var i = 0; i &lt; len; i++)&#123; text = texts[i]; isMatched = pattern.test(text); console.error(text + ": " + isMatched); &#125;&#125; 其结果甚是诡异，把爹坑得郁闷不已。 百思不得其解之下，只好借助网络。终于，在w3schools中找到了问题的关键所在。 原来，RegExp的对象有一个很NB的lastIndex属性，当我们调用方法 exec() 或 test()时，RegExp对象会用它来记录最近一次成功匹配后的位置，并将其作为下一次检索的起始点。只有当方法 exec() 或 test() 再也找不到可以匹配的文本时，它们会自动把 lastIndex 属性重置为 0。 12345678910111213var texts = ["item1", "item2", "item3", "item4", "item5", "item6"];var pattern = new RegExp("it", "ig");function check() &#123; var len = texts.length, text, isMatched = false; for(var i = 0; i &lt; len; i++)&#123; text = texts[i]; var result = "LastIndex: " + pattern.lastIndex; isMatched = pattern.test(text); result = result + " " + text + ": " + isMatched; console.error(result); &#125;&#125; 如此，在”item2”, “item4”, “item6”中从索引位置2开始检索关键字“it”，当然是找不到的了。因为对同一个RegExp对象而言，“终点即起点，执着何用。”显然，我们需要从头开始，从0开始。我们需要在做完一次exec() 或 test()后手动将lastIndex重新设置为0。例如： 123456789101112131415var texts = ["item1", "item2", "item3", "item4", "item5", "item6"];var pattern = new RegExp("it", "ig");function check() &#123; var len = texts.length, text, isMatched = false; for(var i = 0; i &lt; len; i++)&#123; text = texts[i]; var result = "LastIndex: " + pattern.lastIndex; isMatched = pattern.test(text); result = result + " " + text + ": " + isMatched; console.error(result); pattern.lastIndex = 0; &#125;&#125; 惟有如此，事可成也。 其实所谓“坑爹”之说，不过是遇事未能详查，徒添困扰罢了。w3schools在对RegExp的lastIndex进行解说时早已明确写明： 提示和注释 重要事项：不具有标志 g 和不表示全局模式的 RegExp 对象不能使用 lastIndex 属性。 提示：如果在成功地匹配了某个字符串之后就开始检索另一个新的字符串，需要手动地把这个属性设置为 0。 今记录于此，以鉴后来之事。]]></content>
      <categories>
        <category>软件开发</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Dev</tag>
        <tag>RIA</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to proxy a web site by apache2 in Ubuntu]]></title>
    <url>%2F2017%2F02%2F27%2Finstall-and-config-apach-in-ubuntu%2F</url>
    <content type="text"><![CDATA[Install apache2To execute the install command in terminal: sudo apt-get install apache2 Then, we can find that the apache2 has been installed in “/etc/“ directory. eric@eric:cd /etc/apache2 eric@eric:/etc/apache2$ apache2 -version Server version: Apache/2.4.7 (Ubuntu) Server built: Apr 3 2014 12:20:28 eric@eric:/etc/apache2# ls -l total 80 -rw-r--r-- 1 root root 7115 Jan 7 21:23 apache2.conf drwxr-xr-x 2 root root 4096 Jun 17 15:09 conf-available drwxr-xr-x 2 root root 4096 Jun 17 15:09 conf-enabled -rw-r--r-- 1 root root 1782 Jan 3 22:48 envvars -rw-r--r-- 1 root root 31063 Jan 3 22:48 magic drwxr-xr-x 2 root root 12288 Jun 17 15:09 mods-available drwxr-xr-x 2 root root 4096 Jun 17 15:09 mods-enabled -rw-r--r-- 1 root root 320 Jan 7 21:23 ports.conf drwxr-xr-x 2 root root 4096 Jun 17 15:08 sites-available drwxr-xr-x 2 root root 4096 Jun 17 15:09 sites-enabled Attention:After executing the install command, some echo exception messages may shown like that. AH00558: apache2: Could not reliably determine the server&apos;s fully qualified domain name, using 127.0.1.1. Set the &apos;ServerName&apos; directive globally to suppress this message (98)Address already in use: AH00072: make_sock: could not bind to address [::]:80 (98)Address already in use: AH00072: make_sock: could not bind to address 0.0.0.0:80 no listening sockets available, shutting down If so, we need to: 1) Config the “ServerName” in apache2.conf. eric@eric:cd /etc/apache2 eric@eric:cd vi apache2.conf ... ServerName localhost ... 2) End the existed process which is using the 80 socket. netstat -ap | grep 80 lsof -i:80 kill {PID} Or modify the listen socket. (See Config listening ports) Then, we can restart apache2. eric@eric:sudo /etc/init.d/apache2 restart Config listening ports We can change and add the listening ports by modifying port.conf file in “/etc/apache2/“. eric@eric:sudo vi /etc/apache2/ports.conf For example, we change the default port from 80 to 81 to avoid the in used portd. Listen 81 &lt;IfModule ssl_module&gt; Listen 443 &lt;/IfModule&gt; &lt;IfModule mod_gnutls.c&gt; Listen 443 &lt;/IfModule&gt; After changing the default port, the default site configuration (/etc/apache2/sites-enabled/000-default.conf) also need be updated. eric@eric:sudo vi /etc/apache2/sites-enabled/000-default.conf Modify &lt;VirtualHost *:80&gt; as &lt;VirtualHost *:81&gt; Config proxy or reverse proxyHere, there is a Tomcat worked in 8080 port as our J2EE server and an application named “jreport” running in it. We will config the apache to proxy it. 1. Activate proxy moduleThere are “mods-available” and “mods-enabled” two directories in apache. The “mods-available” directory includes all available module configuration files. If we want to make them take effect, they must be copied or linked into the “mods-enabled” directory. For activating the proxy module, we create some soft link for “proxy.load”, “proxy_http.load” and “proxy.conf”. eric@eric:/etc/apache2/mods-enabled$ sudo ln -s ../mods-available/proxy.load eric@eric:/etc/apache2/mods-enabled$ sudo ln -s ../mods-available/proxy_http.load eric@eric:/etc/apache2/mods-enabled$ sudo ln -s ../mods-available/proxy.conf Then, execute the a2enmod command. eric@eric:/etc/apache2$ a2enmod proxy 2. Config proxyAfter activating the proxy module, we can config the “Forward Proxy” or “Reverse Proxy” for the “jreport” application in Tomcat. Reverse Proxy Reverse proxy is the most used way. ProxyRequests Off ProxyPass /jreport ${JREPORT_SERVER}/jreport ProxyPassReverse /jreport ${JREPORT_SERVER}/jreport or ProxyRequests Off Timeout 36000 ProxyTimeout 36000 &lt;Location /jreport/&gt; ProxyPass ${JREPORT_SERVER}/jreport ProxyPassReverse ${JREPORT_SERVER}/jreport ProxyPassReverseCookiePath /jreport / &lt;/Location&gt; For easy to config, we define a variable named “JREPORT_SERVER” in “/etc/apache2/envvars”. export JREPORT_SERVER=http://192.168.0.88:8080 After restarting the apache with the latest configuration, we can access the “jreport” application with: http://localhost:81/jreport Forward Proxy For example, to control who can access your proxy: ProxyRequests On ProxyVia On &lt;Proxy *&gt; Require ip 192.168.0 &lt;/Proxy&gt; For more details, please see the official doc about [mod_proxy] [2]. Add SSL Support1. Install openssl and ssl_certeric@eric: sudo apt-get install openssl ssl_cert 2. Generate private key and certificationeric@eric: sudo mkdir /etc/apache2/ssl eric@eric: cd /etc/apache2/ssl eric@eric:/etc/apache2/ssl$ sudo openssl genrsa -des3 -out my-server.key 1024 eric@eric:/etc/apache2/ssl$ sudo openssl req -key my-server.key -x509 -out my-server.crt -config /etc/ssl/openssl.cnf -days 3650 3. Activate SSL moduleeric@eric:/etc/apache2/mods-enabled$ sudo ln -s ../mods-available/ssl.load eric@eric:/etc/apache2/mods-enabled$ sudo ln -s ../mods-available/ssl.conf eric@eric:/etc/apache2/mods-enabled$ sudo a2enmod ssl 4. Add SSL support for siteNow, we modify the default site configuration (/etc/apache2/sites-enabled/000-default.conf) to add SSL support and make non-https access use the https automatically. Usually, we config the 443 port for SSL support. &lt;VirtualHost *:81&gt; ... RewriteEngine on RewriteCond %{HTTPS} !=on RewriteRule ^/?(.*)$ https://%{SERVER_NAME}/$1 [L,R] &lt;/VirtualHost&gt; &lt;VirtualHost *:443&gt; SSLEngine on SSLCertificateFile /etc/apache2/ssl/my-server.crt SSLCertificateKeyFiel /etc/apache2/ssl/my-server.key ... &lt;/VirtualHost&gt; PostscriptI have just recorded my first attempt to proxy a web site by apache for memo.There are some other useful and complex modules in apache, such as rewrite, load balance and so on. Reference Apache official doc: [http://httpd.apache.org/docs/2.4/] [1] [1]: http://httpd.apache.org/docs/2.4/ apache doc[2]: http://httpd.apache.org/docs/2.4/mod/mod_proxy.html mode_proxy]]></content>
      <categories>
        <category>软件开发</category>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>Dev</tag>
        <tag>Apache</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
</search>
